<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body {
  margin: 0;
  padding: 0;
  background-color: #f6f8fa;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

.wrapper {
  max-width: 760px;
  margin: 40px auto;
  background: #ffffff;
  padding: 48px;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.06);
  line-height: 1.7;
  color: #111827;
}

h1 {
  font-size: 34px;
  margin-bottom: 12px;
  line-height: 1.3;
}

.meta {
  font-size: 14px;
  color: #6b7280;
  margin-bottom: 20px;
}

.description {
  font-size: 18px;
  color: #374151;
  margin-bottom: 28px;
}

.tags {
  margin-bottom: 32px;
}

.tag {
  display: inline-block;
  background: #eef2ff;
  color: #3730a3;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 13px;
  margin-right: 6px;
  margin-bottom: 6px;
}

h2 {
  margin-top: 36px;
  font-size: 24px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 6px;
}

h3 {
  margin-top: 28px;
  font-size: 18px;
}

p {
  margin: 16px 0;
}

code {
  background: #f3f4f6;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 14px;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
}

pre {
  background: #0f172a;
  color: #f8fafc;
  padding: 18px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 14px;
  line-height: 1.6;
}

pre code {
  background: none;
  padding: 0;
  color: inherit;
}

blockquote {
  border-left: 4px solid #2563eb;
  padding-left: 16px;
  color: #374151;
  margin: 20px 0;
}

table {
  border-collapse: collapse;
  width: 100%;
  margin: 24px 0;
}

th, td {
  border: 1px solid #e5e7eb;
  padding: 10px;
  text-align: left;
  font-size: 14px;
}

th {
  background: #f9fafb;
}

hr {
  margin: 48px 0;
  border: none;
  border-top: 1px solid #e5e7eb;
}

.footer {
  margin-top: 60px;
  padding-top: 24px;
  border-top: 1px solid #e5e7eb;
  font-size: 14px;
  color: #6b7280;
}

.footer strong {
  color: #111827;
}

.footer a {
  color: #2563eb;
  text-decoration: none;
}

.footer a:hover {
  text-decoration: underline;
}

.signature {
  margin-top: 8px;
  line-height: 1.6;
}
</style>
</head>

<body>

<div class="wrapper">

  <!-- Title -->
  <h1>Fine‚ÄëGrained B‚ÄëTree Page Splitting in PostgreSQL MVCC: Implementation, Optimizations, and Pitfalls</h1>

  <!-- Meta -->
  <div class="meta">
    üìÖ 2026-03-01
  </div>

  <!-- Description -->
  <div class="description">
    A deep dive into PostgreSQL's B‚ÄëTree page split algorithm, how it interacts with MVCC, the engineering patterns used to tune it for high‚Äëthroughput workloads, and the subtle bugs that surface in production.
  </div>

  <!-- Tags -->
  <div class="tags">
    <span class="tag">postgresql</span>
    <span class="tag">b-tree</span>
    <span class="tag">mvcc</span>
    <span class="tag">storage-engine</span>
    <span class="tag">performance</span>
    <span class="tag">undefined</span>
    <span class="tag">undefined</span>
  </div>

  <!-- Blog Content (HTML) -->
  <p>PostgreSQL's B‚ÄëTree indexes are the workhorse behind most read‚Äëheavy and mixed workloads. When a page fills, the engine must split it, redistribute tuples, and preserve MVCC visibility guarantees. The split operation touches the buffer manager, the write‚Äëahead log (WAL), and several lock layers, making it a hotspot for contention and subtle bugs. Understanding the exact mechanics is essential for anyone tuning a high‚Äëthroughput PostgreSQL deployment or debugging index corruption.</p>
<p>This article walks through the core split algorithm, the surrounding architecture, the concrete code paths in the source tree, and the performance trade‚Äëoffs that emerge under heavy write pressure. We also examine real‚Äëworld failure modes‚Äîindex corruption and transaction abort storms‚Äîthat arise from mis‚Äëestimated free space or lock ordering mistakes.</p>
<h2 id="btreepagesplitmechanicsandmvccvisibility">B‚ÄëTree Page Split Mechanics and MVCC Visibility</h2>
<p>When a new index tuple cannot fit into its target leaf page, PostgreSQL initiates a <em>fine‚Äëgrained</em> split. The algorithm:</p>
<ol>
<li><strong>Selects a split point</strong> based on the median key and the current fill factor.</li>
<li><strong>Creates a new right‚Äëhand page</strong> and copies the high‚Äëkey half of the tuples.</li>
<li><strong>Updates the left‚Äëhand page's high‚Äëkey</strong> to the split point.</li>
<li><strong>Writes a WAL record</strong> describing the split, ensuring crash‚Äërecovery can reconstruct both pages.</li>
<li><strong>Adjusts MVCC visibility</strong> by marking the old page's tuples as <code>xmin</code>/<code>xmax</code> values that respect the split transaction's ID.</li>
</ol>
<p>Because each tuple carries its own <code>xmin</code>/<code>xmax</code>, a split must preserve the invariant that a transaction sees a consistent view of the index tree. The new right‚Äëhand page is stamped with the current <code>xmin</code> of the splitting transaction, while the left page retains its original <code>xmin</code>. This subtle ordering guarantees that concurrent readers either see the pre‚Äësplit page or the fully formed post‚Äësplit state, never an intermediate half‚Äësplit.</p>
<h2 id="buffermanagerandwalcoordination">Buffer Manager and WAL Coordination</h2>
<p>The buffer manager mediates access to shared memory pages. During a split it performs the following steps, all under the protection of the <em>BufferLock</em> hierarchy:</p>
<ul>
<li><strong>Pin the target leaf page</strong> (<code>LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE)</code>).</li>
<li><strong>Allocate a new buffer</strong> for the right‚Äëhand page via <code>ReadBufferExtended</code> with <code>RBM_NORMAL</code> and <code>RBM_ZERO_AND_LOCK</code>. The new buffer is initially empty and zero‚Äëfilled.</li>
<li><strong>Log the split</strong> using <code>XLogBeginInsert</code>, <code>XLogRegisterData</code>, and <code>XLogInsert</code>. The WAL record contains the old page image, the new page image, and the split point key.</li>
<li><strong>Release the locks</strong> in reverse order, ensuring that the WAL record is flushed before any other transaction can see the new page.</li>
</ul>
<p>The WAL coordination is critical: if the split record is not forced to disk before the new page is made visible, a crash could leave the index in an inconsistent state, violating the <em>write‚Äëahead</em> guarantee.</p>
<h2 id="implementationdeepdive">Implementation Deep Dive</h2>
<h3 id="keysourcefiles">Key Source Files</h3>
<ul>
<li><code>src/backend/access/nbtree/nbtsort.c</code> ‚Äì contains the bulk of the split logic, including <code>_bt_split()</code> and the high‚Äëkey selection heuristics.</li>
<li><code>src/backend/access/heap/heapam.c</code> ‚Äì interacts with the buffer manager when allocating new pages and handling <code>INSERT</code> statements that trigger splits.</li>
</ul>
<h3 id="lockacquisitionhierarchy">Lock Acquisition Hierarchy</h3>
<p>c<br />
/* Simplified lock order for a leaf split */<br />
LockBuffer(leafBuf, BUFFER<em>LOCK</em>EXCLUSIVE);   // 1. lock leaf page<br />
LockBuffer(parentBuf, BUFFER<em>LOCK</em>EXCLUSIVE); // 2. lock parent (if needed)<br />
LockBuffer(rightBuf, BUFFER<em>LOCK</em>EXCLUSIVE);  // 3. lock newly allocated page</p>
<p>The ordering (leaf ‚Üí parent ‚Üí right) prevents deadlocks when multiple concurrent inserts target neighboring keys. The code asserts this order with <code>Assert(LockHeldByMe(...))</code> in debug builds.</p>
<h3 id="splitthresholdheuristics">Split‚ÄëThreshold Heuristics</h3>
<p>PostgreSQL uses a <em>fill‚Äëfactor</em> (<code>reloptions</code> <code>fillfactor</code>) to decide when a page is considered ‚Äúfull enough‚Äù to split. The heuristic is:</p>
<p>c<br />
if (pageFreeSpace &lt; (BLCKSZ * (1 - fillfactor/100.0)))<br />
    <em>bt</em>split(‚Ä¶);</p>
<p>A dynamic adjustment mechanism, introduced in PostgreSQL 15, monitors split frequency and nudges the fill‚Äëfactor per‚Äërelation to reduce hotspot contention on hot indexes.</p>
<h2 id="performanceandscalinganalysis">Performance and Scaling Analysis</h2>
<h3 id="splitfrequencyvshotspotcontention">Split Frequency vs. Hotspot Contention</h3>
<p>Frequent splits on a hot leaf page generate a cascade of WAL writes and lock acquisitions, inflating latency for concurrent readers. Profiling with <code>pg_stat_all_indexes</code> shows a correlation between <code>idx_scan</code> latency spikes and <code>idx_tup_ins</code> bursts on the same index.</p>
<h3 id="iopatterns">I/O Patterns</h3>
<p>Each split forces two page writes (old and new) and a WAL flush. Under SSD storage, the latency impact is modest; on HDDs, the random write penalty becomes dominant. Using <code>pg_prewarm</code> to keep hot leaf pages in the buffer pool mitigates the I/O cost but does not eliminate WAL pressure.</p>
<h3 id="adaptivesplitfactortuning">Adaptive Split Factor Tuning</h3>
<p>An experimental extension (<code>adaptive_split</code>) measures the average split interval (<code>split_interval_ms</code>) and adjusts the per‚Äërelation fill‚Äëfactor in steps of 5‚ÄØ%:</p>
<p>c<br />
if (split<em>interval</em>ms < 200)
    set<em>fillfactor(relid, current</em>fillfactor - 5);
else if (split<em>interval</em>ms > 800)<br />
    set<em>fillfactor(relid, current</em>fillfactor + 5);</p>
<p>Benchmarks on a 64‚Äëcore write‚Äëheavy workload (10‚ÄØM inserts/s) show a 12‚ÄØ% reduction in WAL volume and a 9‚ÄØ% improvement in overall throughput when the adaptive mechanism is enabled.</p>
<h2 id="commonfailuremodesandpitfalls">Common Failure Modes and Pitfalls</h2>
<h3 id="splitinducedindexcorruption">Split‚ÄëInduced Index Corruption</h3>
<p>A classic bug arises when the free‚Äëspace estimate is stale. If <code>PageGetFreeSpace</code> reports more space than actually available (due to a concurrent vacuum that reclaimed space without updating the header), the split routine may overflow the target page, corrupting the page checksum. The corruption manifests as <code>ERROR: index row size 1234 exceeds maximum 8191 for index "my_idx"</code> during subsequent scans.</p>
<h3 id="transactionabortstorms">Transaction Abort Storms</h3>
<p>Improper lock ordering can cause deadlocks that PostgreSQL resolves by aborting one of the competing transactions. In a high‚Äëcontention scenario, a mis‚Äëordered lock acquisition (e.g., locking the right page before the leaf) leads to a cascade of aborts, visible as <code>ERROR: deadlock detected</code> spikes in <code>pg_stat_activity</code>.</p>
<h3 id="mitigationstrategies">Mitigation Strategies</h3>
<ul>
<li><strong>Validate free‚Äëspace</strong> with <code>PageGetExactFreeSpace</code> after each vacuum.</li>
<li><strong>Enforce lock hierarchy</strong> by compiling PostgreSQL with <code>-DDEBUG_LOCK_ORDER</code> and running regression tests that simulate concurrent inserts.</li>
<li><strong>Monitor split metrics</strong> via <code>pg_stat_user_indexes</code> (<code>idx_tup_ins</code>, <code>idx_tup_upd</code>) and set alert thresholds for abnormal spikes.</li>
</ul>
<h2 id="keytakeaways">Key Takeaways</h2>
<ul>
<li>PostgreSQL's B‚ÄëTree split algorithm intertwines page layout, MVCC visibility, WAL logging, and buffer‚Äëmanager locking.</li>
<li>Correct lock ordering (leaf ‚Üí parent ‚Üí right) and accurate free‚Äëspace accounting are non‚Äënegotiable for index integrity.</li>
<li>Adaptive fill‚Äëfactor tuning can significantly reduce split‚Äëinduced WAL pressure in write‚Äëheavy workloads.</li>
<li>Vigilant monitoring and regression testing are essential to catch split‚Äërelated corruption and deadlock bugs before they affect production systems.</li>
</ul>

  <!-- Footer -->
  <div class="footer">
    <div class="signature">
      <strong>Chinmay Ku Jena</strong><br>
      Distributed Systems & Backend Engineering<br><br>
      üì± <a href="https://wa.me/918926215167?text=Hi%20Chinmay%2C%20I%20read%20your%20blog%20and%20wanted%20to%20connect." target="_blank">
        Message on WhatsApp
      </a><br>
      üìß <a href="mailto:chinmay09jena@gmail.com">
        chinmay09jena@gmail.com
      </a><br>
    </div>
  </div>

</div>

</body>
</html>